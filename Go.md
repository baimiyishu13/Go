

---

## 1：聊聊



## 2：聊聊



## 3：学前准备工作

#### 3.3 Hello，World

记事本编写 hello.go

```go
package main

import "fmt" //导入一个系统包"fmt"用来输出的

func main() {
	fmt.Println("Hello,World!") //答应输出Hello,World!字符串
}
```

当前目录下执行：`go run hello.go`

 ![image-20221105165951801](/images/image-20221105165951801.png)

**解释：**

在GO语言中命名为`mian`的包具有特殊的含义，GO语言的编译程序会试图把这种名字的包编译成二进制的可执行的包。所以使用GO语言编译的可执行程序都必须包含一个名交`main`的包，一个可执行的程序有且只有一个`main`包。

当解释器发现某个包的包名为`main`时，它一定也会发现名未`mian()`的函数，否则不会创建可执行文件。

`main()`函数是程序的入口，如果没有这个程序，程序就没办法开始执行。程序编译时，会使用声明`main`包的代码所在的目录的目录名作为二进制可执行文件的文件名。

设置go111module（环境变量）=off

> 准备工作完成！



:bell:



:trophy:











## :bell:基础语法学习



### :trophy: 注释

我们在未来写代码的时候会有一种情况时常发生，刚写完的代码，觉得逻辑清晰，自己怎么这么厉害，然后过了一个月再去看这个代码，就会产生疑问，这个代码到底TM谁写的！所以为了防止自己看不懂自己写的代码。或者你想把你写的代码给别人看，这个时候，我们就需要注释了！

> 注释：你可以理解为写给别人看的，作为一个开源项目。机器不会去执行这些语句。

**注释主要的功能就是为了增强代码的可读性，不参与程序的一切功能，Go语言的注释主要分为两类。**

1. 单行注释
2. 多行注释

```GO
package main

import "fmt"

// 我是单行注釋，程序不会执行，写给自己看的

/*
我是多行注释，使用杠星，星表示在这个区间可以换行写多行注释，也十分常用！
这是一个main函数，这个是go语言的入口
*/

func main() {
	// fmt.Println 打印一句话，然后执行完毕后进行换行
	fmt.Println("Hello,World!")
}
```

写好注释是一个非常良好的习惯，我们都应该按照要求给自己代码写好注释，为了自己，为了他人。很多大公司也是对注释有严格的要求。



### :trophy:变量

搞清楚注释后，接下来看一个程序中十分重要的东西，变量！

在数学的概念中，变量表示没固定值且可以改变的。比如x=1，y=2；

字面上的意思理解：变量就是会变化的量，比如我定了一个变量叫做名字；它在Go语言中是这样表示的：这个值可以是张三，也可以是李四，也可以是王五。那么在这里，这个`name`就是变量。可以变化的量。

```GO
//这里的 “=” 是赋值，就是吧等号右边的值，赋值给左边的意思。
package main

import "fmt"

func main() {

	// name 变量
	var name string = "tom"
	fmt.Println(name)

	name = "zhangsan"
	fmt.Println(name)
}
```

**解释：**

​	内存空间-地址编号[0x11112345] 存了一个字符串 `tom`；为这个内存空间定义了一个名字叫`name`；通过这个名字指向了内存空间；空间中的`tom`可以理解未一个盒子，可以拿掉换成`zhangsan`的盒子；

`name`：代表的是一个变量，变量对应的内存底下是串内存地址空间，数据放在空间中；

再次印证了：变量就是会变化的量



#### :four_leaf_clover:变量的定义

Go语言是静态类型语言，就是所有的类型我们都需要明确的定义，我们这里先不管其他类型，先了解string，我们用它来表示字符串！

在Go语言中，声明了一个变量一般是使用var关键字：

```GO
var name type
```

+ 第一个var：声明变量的关键字，是固定写法，要声明一个变量就需要一个var。
+ 第二个name：就是我们变量的名字，按照需求起一个名字，用来后续使用！
+ 第三个type，就是用来表示变量的类型。

举个例子：

```GO
// 定义一个字符串变量 name
var name string

// 定一个数字类型变量 age
var age int

```

Go和其他许多编程语言不通同，他在声明变量时间变量的类型放在变量名之后，这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：`int* a,b;` 其中只有是指针而b不是。如果想要这两变量都是指针，则需要将它们分开书写。而在GO中，则可以很简单的将其声明指针类型：

```go
var a,b *int
```

变量的明明规则遵循骆驼命名法，即每个新单词首个字母大写，例如：userFile和 systemInfo。

> 定义变量的标准格式为

```
var 变量名 变量类型
```

变量声明以关键字开头，后置变量类型，行尾无需分号！

> 我们有时候会批量定义变量，如果每次单独定义会很麻烦，Go语言支持批量定义变量

是有关键字var和括号，可以将变量定义放在一起。

```GO
func main() {
    // var 定义变量，如果没有赋值，变量就默认是这个类型的默认值
	var (
		name string
		age  int
		addr string
	)
	// strint默认值：空
	// int默认值：0
	fmt.Println(name, age, addr)
}
```

var 形式的声明语句 往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要地方。

当一个变量被声明后，如果没有显示的给它赋值，系统会自动赋予它该类型的零值

+ 整型和浮点型的默认值是`0`  和`0.0`
+ 字符串变量的默认值为`空字符串`
+ 布尔型变量默认值为`false`
+ 切片、函数、指针变量默认值为`nil`



#### :four_leaf_clover:变量的初始化

> 变量初始化的标准格式

```go
var 变量名 类型 = 值(表达式)
```

比如，想定义`zhangsan`的一些信息，可以表示

```GO
func main() {
	var name1 string = "zhangsan"
	var age1 int = 18
	fmt.Printf("name:%s,age:%d", name1, age1)
}
```

这里的name和age就是变量名，name的类型为string，age的类型为int，他们的值分别为`张三`和`18`

> 短变量声明初始化
>

```go
// := 自动推到
name2 := "zhangsan"
age2 := 18
```

这是Go语言的推导声明写法，编译器会自动根据右值推断出左值的类型。

它可以自动推导出一些类型，但是使用也是有限制的；

+ 定义变量，同时显式初始化
+ 不能提供数据类型
+ 只是用在函数内部，不能随便到处定义

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。

注意：由于使用了 `:=`, 而不是赋值的=，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。

```GO
// 定义变量 name
var name string
// 定义变量 name，并赋值“zhangsan”
name := "zhangsan"
```

编译会报错，信息如下：

```GO
.\demo04.go:14:7: no new variables on left side of :=
```



#### :four_leaf_clover:理解变量（内存地址）

Printf：

+ %d：打印数字类型
+ %p：打印内存地址 (取地址符 &变量名)

```GO
	var num int
	num = 1000
	fmt.Printf("num的值:%d,内存地址:%p\n", num, &num)
    //num的值:1000,内存地址:0xc000020098

	num = 2000
	fmt.Printf("num的值:%d,内存地址:%p\n", num, &num) //取地址符 &变量名
	//num的值:2000,内存地址:0xc000020098
```



#### :four_leaf_clover:变量的交换

传统语言交换方式

```c++
// 在编程中，最简单的就是内存交换了，但是我们一般常见的方式就是定义中间变量
a = 100
b = 200
temp = 0
temp = a  // 第一步a存成了temp
a = b     // 第二步b赋值给a
b = temp  // 第三步temp赋值给b
```

Go语言有个十分简单的写法：

```GO
func main() {
    var a int = 100
	var b int = 200
	 
    // 在Go 语言中，可以直接这样来实现换值，不需要中间变量了。
	b, a = a, b
	fmt.Println(a, b)
}
```



#### :four_leaf_clover:匿名变量

匿名变量的特点是一个下划线`_`,`_`本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋值给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方是有下划线代替即可，例如

```GO
package main

import "fmt"
/*，
定义一个test()函数，它返回两个int类型的值，每次调用返回 100 和 200 俩个数值。
 */
func test() (int, int) {
	return 100, 200
}
func main() {
	// test() 函数返回两个值 100 和 200； 只需要第一个值，匿名函数废弃掉第二个值 即匿名函数 _
	a, _ := test()
	_,b := test()
	fmt.Println(a,b) //输出 100.200
}
```

编码过程中，可能遇到没有名称的变量名、类型、方法。虽然这不是必须的，但是有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。

匿名变量不占用内存空间，不会分配内存，匿名变量与匿名变量之间也不会因为多次声明而无法使用



#### :four_leaf_clover:匿名的作用域

**一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为：作用域**

了解变量的作用域对学习Go语言是比较重要的，因为Go语言会在编译时检查么个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。

> 局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只有在函数体内，函数的参数和返回值变量都属于局部变量。

```go
func main() {
	// 声明局部变量 a和b 的和
	var a int = 3
	var b int = 4
	// 声明局部变量 c 并计算 a 和 b 的和
	c := a + b
	fmt.Printf("a=%d,b=%d,c=%d\n", a, b, c) //a=3,b=4,c=7
}
```

> 全局变量

在函数体外声明的变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个局部变量的源文件需要使用`import` 关键字引入全局变量所在的文件源文件之后才能使用这个全局变量。

全局变量声明必须以var关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。

```GO
// 声明全局便量
var c int
func main() {
	// 声明局部变量 a和b 的和
	var a int = 3
	var b int = 4
	// 声明局部变量 c 并计算 a 和 b 的和
	c = a + b
	fmt.Printf("a=%d,b=%d,c=%d\n", a, b, c) //a=3,b=4,c=7
}
```

Go语言程序中全局变量和局部变量 名称可以相同，但是函数体内的`局部变量`会被优先考虑。

```gO
// 声明全局变量
var a float64 = 3.14

func main() {
	//声明局部变量
	var a int = 3
	fmt.Println(a) // a = 3
}
```



#### :four_leaf_clover:常量

**常量是一个简单值的标识符，在程序运行时，不会被修改的量**

注意：常量中的数据值可以是布尔值、数字型（整数型、浮点型和复数）和字符串型。

```go
const identifier [type] = value
```

可以省略类型说明符，因为编译器可以根据变量的值来推断其类型。

+ 显式类型定义：`const b string = “abc”`
+ 隐式类型定义：`Const b = "abc"`

多个相同类型的声明可以简写为：

```SH
const c_name1, c_name2 = value1, value2
```

常量的定义：const

```GO
func main() {
	const url string = "www.baidu.com"     //显式定义
	const url2 = "www.baidu.com"           //隐式定义
	const a, b, c = 3.14, "zhangsan", true //同时定义多个常量

	fmt.Println(url)
	fmt.Println(url2)
	fmt.Println(a, b, c) //3.14 zhangsan true
}
```



#### :four_leaf_clover:常量iota

中文名是“埃欧塔”，计数器

iota：特殊常量，可以认为是一个可以被编译器修改的常量，iota是go语言的**常量计数器**

iota在const关键字出现时将被重置为0 （const 内部的第一行之前），const中每新增一行常量声明将使iota可理解为const语句块中的索引。

iota可以被用作枚举值：

```GO
	const (
		a = iota
		b = iota
		c = iota
	)
```

第一个iota等于0，每当iota在新的一行被使用时，它的值都会自动加1；所以a=0,b=1,c=2 可以简写如下形式：

iota无论走不走都会进行计数，直到它的恢复！

```GO
	const (
		a = iota	// 0
		b			// 1
		c			// 2
		d = "haha"	// haha iota 3
        e			// haha iota 4 (e 如果不赋值，默认 haha)
        f = iota  	// 5 	iota 5	(恢复iota计数)
		j			// 6	iota 6
	)
	//新的一组会恢复计数
	const (
		n = iota	// 0
		m			// 1
	)
```

例子：



### :trophy: 基本数据类型

Go语言是一种静态类型的编程语言，在Go编程语言中，数据类型用于声明声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存就可以充分利用内存。编辑器在进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。

 ![image-20221106201935065](/images/image-20221106201935065.png)

#### :four_leaf_clover:布尔型

布尔型的值只有两个 `true`和`false`，一个简单的例子：var b bool = true、

```go
func main() {
   // var 变量名 数据类型
   // bool: true false(默认值)
   var isFlage1 bool        // false
   var isFlage2 bool = true //trye

   fmt.Printf("%T,%t\n", isFlage1, isFlage1) //bool,false
   fmt.Printf("%T,%t\n", isFlage2, isFlage2) //bool,true
}
```

#### :four_leaf_clover:数值型

整形 int 和 浮点型 float32、float64 ，Go语言支持整形和浮点型数字，并且支持复数，其中位的运算采用补码。

> Go也有基于框架结构的类型，例如：uint无符号，int有符号

| 序号 | 类型 & 描述                                       |
| ---- | ------------------------------------------------- |
| 1    | uint8 无符号 8 位整数（0到255）                   |
| 2    | uint16 无符号 16 位整数（0到65535）               |
| 3    | uint32 无符号 32 位整数（0到4229496795）          |
| 4    | uint64 无符号 64位整数（0到18446744073709551615） |
| 5    | int8 有符号 8 位整数（-128-127）                  |
| 6    | int16 有符号 16 位整数（-128-127）                |
| 7    | int32 有符号 23 位整数（-128-127）                |
| 8    | int64 有符号 46 位整数（-128-127）                |

```go
func main() {
   // 定义一个整形
   var age int = 8
   fmt.Printf("%T,%d\n", age, age) //int,8
}
```

> 浮点型

| 浮点型 | 类型 & 描述                   |
| ------ | ----------------------------- |
| 1      | float32 IEEE-754 32位浮点型数 |
| 2      | float64 I-EEE754 64位浮点型数 |
| 3      | complex64 32位实数和虚数      |
| 4      | complex64 64位实数和虚数      |

```go
func main() {
   var f1 float32
   f1 = 3.14
   var f2 float64
   f2 = 5.12
   // %f 默认保留小6位数，%.2f就是暴力两位，%.3f就是暴力3位
   fmt.Printf("%T,%f\n", f1, f1)
   fmt.Printf("%T,%.3f\n", f2, f2)
}
```

1. 关于浮点数在机器中存放形式的简单说明：**浮点数=符号位+指数位+尾数位**
2. 尾数数部分可能丢失，造成精度损失。-123.0000901

```go
var num1 float32 = -123.0000901
var num2 float64 = -123.0000901
//num1 = -123.00009 num2 = -123.0000901
fmt.Println("num1 =", num1, "num2 =", num2)
```

说明：

1. float64 精度要比float32 准确
2. 保存高精度数值，应该使用float64

浮点型的存储分为三个部分：**符号位+指数位+尾数位**，在存储过程中，精度可能会有丢失

goland的浮点型默认`float64类型`

通常情况下，应该使用float64，因为它比float32更精确

> 以下列出了其他更多的数字类型：

| 序号 | 类型 & 描述                          |
| ---- | ------------------------------------ |
| 1    | byte 类似 uint8                      |
| 2    | rune 类似 int32                      |
| 3    | uint32 或64位                        |
| 4    | int 与 uint 一样大小                 |
| 5    | uintptr 无符号整型，用于存放一个指针 |



#### :four_leaf_clover:字符串型

















