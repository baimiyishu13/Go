## :bell:学前准备工作

#### :trophy: Hello，World

记事本编写 hello.go


```go
package main

import "fmt" //导入一个系统包"fmt"用来输出的

func main() {
	fmt.Println("Hello,World!") //答应输出Hello,World!字符串
}
```

当前目录下执行：`go run hello.go`

 ![image-20221105165951801](/images/image-20221105165951801.png)

**解释：**

在GO语言中命名为`mian`的包具有特殊的含义，GO语言的编译程序会试图把这种名字的包编译成二进制的可执行的包。所以使用GO语言编译的可执行程序都必须包含一个名交`main`的包，一个可执行的程序有且只有一个`main`包。

当解释器发现某个包的包名为`main`时，它一定也会发现名未`mian()`的函数，否则不会创建可执行文件。

`main()`函数是程序的入口，如果没有这个程序，程序就没办法开始执行。程序编译时，会使用声明`main`包的代码所在的目录的目录名作为二进制可执行文件的文件名。

设置go111module（环境变量）=off

> 准备工作完成！



:bell:



:trophy:











## :bell:基础语法学习



### :trophy: 注释

我们在未来写代码的时候会有一种情况时常发生，刚写完的代码，觉得逻辑清晰，自己怎么这么厉害，然后过了一个月再去看这个代码，就会产生疑问，这个代码到底TM谁写的！所以为了防止自己看不懂自己写的代码。或者你想把你写的代码给别人看，这个时候，我们就需要注释了！

> 注释：你可以理解为写给别人看的，作为一个开源项目。机器不会去执行这些语句。

**注释主要的功能就是为了增强代码的可读性，不参与程序的一切功能，Go语言的注释主要分为两类。**

1. 单行注释
2. 多行注释

```GO
package main

import "fmt"

// 我是单行注釋，程序不会执行，写给自己看的

/*
我是多行注释，使用杠星，星表示在这个区间可以换行写多行注释，也十分常用！
这是一个main函数，这个是go语言的入口
*/

func main() {
	// fmt.Println 打印一句话，然后执行完毕后进行换行
	fmt.Println("Hello,World!")
}
```

写好注释是一个非常良好的习惯，我们都应该按照要求给自己代码写好注释，为了自己，为了他人。很多大公司也是对注释有严格的要求。



### :trophy:变量

搞清楚注释后，接下来看一个程序中十分重要的东西，变量！

在数学的概念中，变量表示没固定值且可以改变的。比如x=1，y=2；

字面上的意思理解：变量就是会变化的量，比如我定了一个变量叫做名字；它在Go语言中是这样表示的：这个值可以是张三，也可以是李四，也可以是王五。那么在这里，这个`name`就是变量。可以变化的量。

```GO
//这里的 “=” 是赋值，就是吧等号右边的值，赋值给左边的意思。
package main

import "fmt"

func main() {

	// name 变量
	var name string = "tom"
	fmt.Println(name)

	name = "zhangsan"
	fmt.Println(name)
}
```

**解释：**

​	内存空间-地址编号[0x11112345] 存了一个字符串 `tom`；为这个内存空间定义了一个名字叫`name`；通过这个名字指向了内存空间；空间中的`tom`可以理解未一个盒子，可以拿掉换成`zhangsan`的盒子；

`name`：代表的是一个变量，变量对应的内存底下是串内存地址空间，数据放在空间中；

再次印证了：变量就是会变化的量



#### :four_leaf_clover:变量的定义

Go语言是静态类型语言，就是所有的类型我们都需要明确的定义，我们这里先不管其他类型，先了解string，我们用它来表示字符串！

在Go语言中，声明了一个变量一般是使用var关键字：

```GO
var name type
```

+ 第一个var：声明变量的关键字，是固定写法，要声明一个变量就需要一个var。
+ 第二个name：就是我们变量的名字，按照需求起一个名字，用来后续使用！
+ 第三个type，就是用来表示变量的类型。

举个例子：

```GO
// 定义一个字符串变量 name
var name string

// 定一个数字类型变量 age
var age int

```

Go和其他许多编程语言不通同，他在声明变量时间变量的类型放在变量名之后，这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：`int* a,b;` 其中只有是指针而b不是。如果想要这两变量都是指针，则需要将它们分开书写。而在GO中，则可以很简单的将其声明指针类型：

```go
var a,b *int
```

变量的明明规则遵循骆驼命名法，即每个新单词首个字母大写，例如：userFile和 systemInfo。

> 定义变量的标准格式为

```
var 变量名 变量类型
```

变量声明以关键字开头，后置变量类型，行尾无需分号！

> 我们有时候会批量定义变量，如果每次单独定义会很麻烦，Go语言支持批量定义变量

是有关键字var和括号，可以将变量定义放在一起。

```GO
func main() {
    // var 定义变量，如果没有赋值，变量就默认是这个类型的默认值
	var (
		name string
		age  int
		addr string
	)
	// strint默认值：空
	// int默认值：0
	fmt.Println(name, age, addr)
}
```

var 形式的声明语句 往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要地方。

当一个变量被声明后，如果没有显示的给它赋值，系统会自动赋予它该类型的零值

+ 整型和浮点型的默认值是`0`  和`0.0`
+ 字符串变量的默认值为`空字符串`
+ 布尔型变量默认值为`false`
+ 切片、函数、指针变量默认值为`nil`



#### :four_leaf_clover:变量的初始化

> 变量初始化的标准格式

```go
var 变量名 类型 = 值(表达式)
```

比如，想定义`zhangsan`的一些信息，可以表示

```GO
func main() {
	var name1 string = "zhangsan"
	var age1 int = 18
	fmt.Printf("name:%s,age:%d", name1, age1)
}
```

这里的name和age就是变量名，name的类型为string，age的类型为int，他们的值分别为`张三`和`18`

> 短变量声明初始化
>

```go
// := 自动推到
name2 := "zhangsan"
age2 := 18
```

这是Go语言的推导声明写法，编译器会自动根据右值推断出左值的类型。

它可以自动推导出一些类型，但是使用也是有限制的；

+ 定义变量，同时显式初始化
+ 不能提供数据类型
+ 只是用在函数内部，不能随便到处定义

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。

注意：由于使用了 `:=`, 而不是赋值的=，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。

```GO
// 定义变量 name
var name string
// 定义变量 name，并赋值“zhangsan”
name := "zhangsan"
```

编译会报错，信息如下：

```GO
.\demo04.go:14:7: no new variables on left side of :=
```



#### :four_leaf_clover:理解变量（内存地址）

Printf：

+ %d：打印数字类型
+ %p：打印内存地址 (取地址符 &变量名)

```GO
	var num int
	num = 1000
	fmt.Printf("num的值:%d,内存地址:%p\n", num, &num)
    //num的值:1000,内存地址:0xc000020098

	num = 2000
	fmt.Printf("num的值:%d,内存地址:%p\n", num, &num) //取地址符 &变量名
	//num的值:2000,内存地址:0xc000020098
```



#### :four_leaf_clover:变量的交换

传统语言交换方式

```c++
// 在编程中，最简单的就是内存交换了，但是我们一般常见的方式就是定义中间变量
a = 100
b = 200
temp = 0
temp = a  // 第一步a存成了temp
a = b     // 第二步b赋值给a
b = temp  // 第三步temp赋值给b
```

Go语言有个十分简单的写法：

```GO
func main() {
    var a int = 100
	var b int = 200
	 
    // 在Go 语言中，可以直接这样来实现换值，不需要中间变量了。
	b, a = a, b
	fmt.Println(a, b)
}
```



#### :four_leaf_clover:匿名变量

匿名变量的特点是一个下划线`_`,`_`本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋值给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方是有下划线代替即可，例如

```GO
package main

import "fmt"
/*，
定义一个test()函数，它返回两个int类型的值，每次调用返回 100 和 200 俩个数值。
 */
func test() (int, int) {
	return 100, 200
}
func main() {
	// test() 函数返回两个值 100 和 200； 只需要第一个值，匿名函数废弃掉第二个值 即匿名函数 _
	a, _ := test()
	_,b := test()
	fmt.Println(a,b) //输出 100.200
}
```

编码过程中，可能遇到没有名称的变量名、类型、方法。虽然这不是必须的，但是有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。

匿名变量不占用内存空间，不会分配内存，匿名变量与匿名变量之间也不会因为多次声明而无法使用



#### :four_leaf_clover:匿名的作用域

**一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为：作用域**

了解变量的作用域对学习Go语言是比较重要的，因为Go语言会在编译时检查么个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。

> 局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只有在函数体内，函数的参数和返回值变量都属于局部变量。

```go
func main() {
	// 声明局部变量 a和b 的和
	var a int = 3
	var b int = 4
	// 声明局部变量 c 并计算 a 和 b 的和
	c := a + b
	fmt.Printf("a=%d,b=%d,c=%d\n", a, b, c) //a=3,b=4,c=7
}
```

> 全局变量

在函数体外声明的变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个局部变量的源文件需要使用`import` 关键字引入全局变量所在的文件源文件之后才能使用这个全局变量。

全局变量声明必须以var关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。

```GO
// 声明全局便量
var c int
func main() {
	// 声明局部变量 a和b 的和
	var a int = 3
	var b int = 4
	// 声明局部变量 c 并计算 a 和 b 的和
	c = a + b
	fmt.Printf("a=%d,b=%d,c=%d\n", a, b, c) //a=3,b=4,c=7
}
```

Go语言程序中全局变量和局部变量 名称可以相同，但是函数体内的`局部变量`会被优先考虑。

```gO
// 声明全局变量
var a float64 = 3.14

func main() {
	//声明局部变量
	var a int = 3
	fmt.Println(a) // a = 3
}
```



#### :four_leaf_clover:常量

**常量是一个简单值的标识符，在程序运行时，不会被修改的量**

注意：常量中的数据值可以是布尔值、数字型（整数型、浮点型和复数）和字符串型。

```go
const identifier [type] = value
```

可以省略类型说明符，因为编译器可以根据变量的值来推断其类型。

+ 显式类型定义：`const b string = “abc”`
+ 隐式类型定义：`Const b = "abc"`

多个相同类型的声明可以简写为：

```SH
const c_name1, c_name2 = value1, value2
```

常量的定义：const

```GO
func main() {
	const url string = "www.baidu.com"     //显式定义
	const url2 = "www.baidu.com"           //隐式定义
	const a, b, c = 3.14, "zhangsan", true //同时定义多个常量

	fmt.Println(url)
	fmt.Println(url2)
	fmt.Println(a, b, c) //3.14 zhangsan true
}
```



#### :four_leaf_clover:常量iota

中文名是“埃欧塔”，计数器

iota：特殊常量，可以认为是一个可以被编译器修改的常量，iota是go语言的**常量计数器**

iota在const关键字出现时将被重置为0 （const 内部的第一行之前），const中每新增一行常量声明将使iota可理解为const语句块中的索引。

iota可以被用作枚举值：

```GO
	const (
		a = iota
		b = iota
		c = iota
	)
```

第一个iota等于0，每当iota在新的一行被使用时，它的值都会自动加1；所以a=0,b=1,c=2 可以简写如下形式：

iota无论走不走都会进行计数，直到它的恢复！

```GO
	const (
		a = iota	// 0
		b			// 1
		c			// 2
		d = "haha"	// haha iota 3
        e			// haha iota 4 (e 如果不赋值，默认 haha)
        f = iota  	// 5 	iota 5	(恢复iota计数)
		j			// 6	iota 6
	)
	//新的一组会恢复计数
	const (
		n = iota	// 0
		m			// 1
	)
```

例子：



### :trophy: 基本数据类型

Go语言是一种静态类型的编程语言，在Go编程语言中，数据类型用于声明声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存就可以充分利用内存。编辑器在进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。

 ![image-20221106201935065](/images/image-20221106201935065.png)

#### :four_leaf_clover:布尔型

布尔型的值只有两个 `true`和`false`，一个简单的例子：var b bool = true、

```go
func main() {
   // var 变量名 数据类型
   // bool: true false(默认值)
   var isFlage1 bool        // false
   var isFlage2 bool = true //trye

   fmt.Printf("%T,%t\n", isFlage1, isFlage1) //bool,false
   fmt.Printf("%T,%t\n", isFlage2, isFlage2) //bool,true
}
```

#### :four_leaf_clover:数值型

整形 int 和 浮点型 float32、float64 ，Go语言支持整形和浮点型数字，并且支持复数，其中位的运算采用补码。

> Go也有基于框架结构的类型，例如：uint无符号，int有符号

| 序号 | 类型 & 描述                                       |
| ---- | ------------------------------------------------- |
| 1    | uint8 无符号 8 位整数（0到255）                   |
| 2    | uint16 无符号 16 位整数（0到65535）               |
| 3    | uint32 无符号 32 位整数（0到4229496795）          |
| 4    | uint64 无符号 64位整数（0到18446744073709551615） |
| 5    | int8 有符号 8 位整数（-128-127）                  |
| 6    | int16 有符号 16 位整数（-128-127）                |
| 7    | int32 有符号 23 位整数（-128-127）                |
| 8    | int64 有符号 46 位整数（-128-127）                |

```go
func main() {
   // 定义一个整形
   var age int = 8
   fmt.Printf("%T,%d\n", age, age) //int,8
}
```

> 浮点型

| 浮点型 | 类型 & 描述                   |
| ------ | ----------------------------- |
| 1      | float32 IEEE-754 32位浮点型数 |
| 2      | float64 I-EEE754 64位浮点型数 |
| 3      | complex64 32位实数和虚数      |
| 4      | complex64 64位实数和虚数      |

```go
func main() {
   var f1 float32
   f1 = 3.14
   var f2 float64
   f2 = 5.12
   // %f 默认保留小6位数，%.2f就是暴力两位，%.3f就是暴力3位
   fmt.Printf("%T,%f\n", f1, f1)
   fmt.Printf("%T,%.3f\n", f2, f2)
}
```

1. 关于浮点数在机器中存放形式的简单说明：**浮点数=符号位+指数位+尾数位**
2. 尾数数部分可能丢失，造成精度损失。-123.0000901

```go
var num1 float32 = -123.0000901
var num2 float64 = -123.0000901
//num1 = -123.00009 num2 = -123.0000901
fmt.Println("num1 =", num1, "num2 =", num2)
```

说明：

1. float64 精度要比float32 准确
2. 保存高精度数值，应该使用float64

浮点型的存储分为三个部分：**符号位+指数位+尾数位**，在存储过程中，精度可能会有丢失

goland的浮点型默认`float64类型`

通常情况下，应该使用float64，因为它比float32更精确

> 以下列出了其他更多的数字类型：

| 序号 | 类型 & 描述                          |
| ---- | ------------------------------------ |
| 1    | byte 类似 uint8                      |
| 2    | rune 类似 int32                      |
| 3    | uint32 或64位                        |
| 4    | int 与 uint 一样大小                 |
| 5    | uintptr 无符号整型，用于存放一个指针 |



#### :four_leaf_clover:字符串型


字符串就是一串固定长度的字符连接起来的字符序列。

Go的字符串是由单个字符连接起来的，Go语言的字符串的字节使用UTF-8编码标识 Unicode文本。

```go
package main

import "fmt"

func main() {
	var str string
	str = "Hello World"
	fmt.Printf("%T,%s\n", str, str) //string,Hello World

	//单引号和双引号的区别，单引号 字符，ascii字符码
	v1 := 'A'
	v2 := "A"
	fmt.Printf("%T,%d\n", v1, v1) //int32,65
	fmt.Printf("%T,%s\n", v2, v2) //string,A

	/*
		扩展知识
		中国的编码表：GBK
		全世界的编码表：Unicode编码表，号称兼容了全世界的文字
	*/
	v3 := '中'
	fmt.Printf("%T,%d\n", v3, v3) //int32,20013
}
```

Go语言的字符串连接可以通过 + 实现：

```Go
fmt.Println("zhang" + "san") //zhangsan 
```

转义字符：

```go
fmt.Println("Hello\" Go")
fmt.Println("Hello\n Go") // n 换行
fmt.Println("Hello\t Go") // t 制表符
```



#### :four_leaf_clover:数据类型转换

再必要以及可执行的情况下，一个类型的值可以被转换成另一种类型的值，由于Go语言不存在隐式类型转换。因此所有的类型转换都必须显式声明：

```go
valueofTypeB = typeB(valueofTypeA)
```

类型B的值 = 类型B(类型A的值)

```go
func main() {
   a := 5.0    // float
   b := int(a) // 转为int
    
    //需求：将int类型的 a 转换成位 float64 类型 类型转换
	c := float64(a)
	fmt.Printf("%T\n", c) //float64

    d := byte(a)
	fmt.Printf("%T,%d\n", d, d) //uint8,5

    fmt.Printf("%T,%f\n", a, a) //float64,5.000000
    fmt.Printf("%T,%d\n", b, b) //int,5
}
```

类型转换只能再定义正确的情况下转换成功，例如：

+ 冲一个取值范围小的类型，转换成一个取值范围大的类型（int16 转成 int32）

当从一个取值范围较大的类型转到取值范围较小的类型时，（int32 转 int16 或者其他），会发生精度丢失（截断）的情况！



### :trophy:运算符

+ 算数运算符
+ 关系运算符
+ 逻辑运算符
+ 位运算符
+ 赋值运算符
+ 其他运算符

 ![image-20221108164249728](/images/operator.png)

#### :four_leaf_clover:算数运算符

下表列出了所有Go语言的算数运算符，假定A值位10，B值位20

| 运算符 | 描述 | 实例                  |
| ------ | ---- | --------------------- |
| +      | 相加 | A + B 输出结果为30    |
| -      | 相减 | A - B 输出结果位为-10 |
| *      | 相乘 | A * B 输出结果为 200  |
| \      | 相除 | B \ A 输出结果为 2    |
| %      | 求余 | B % A输出结果为 0     |
| ++     | 自增 | A++ 输出结果为 11     |
| --     | 自减 | A-- 输出结果为9       |

```go
func main() {
   var a int = 10
   var b int = 3
   //var c int

   // + - * / % ++ --
   fmt.Println(a + b)
   fmt.Println(a - b)
   fmt.Println(a * b)
   fmt.Println(a / b)
   a++	// a = a+1
   fmt.Println(a)
   a--	// a = a-1
   fmt.Println(a)
}
```



#### :four_leaf_clover:关系运算符

下表列出了所有Go语言的关系运算符，假定A值为10，B值为20.

返回：True、False

| 运算符 | 描述                                                |                   |
| ------ | --------------------------------------------------- | ----------------- |
| ==     | 检查两个值是否相等，如果是返回True负责返回False     | (A == B) 为 False |
| !=     | 检查两个值是否不相等，如果是返回True负责返回False   | A != B) 为 True   |
| >      | 检查左边值是否大于右边，如果是返回True负责返回False | A > B) 为 False   |
| <      | 检查左边值是否小于右边，如果是返回True负责返回False | A < B) 为 True    |
| >=     | 检查左边值是否大于右边，如果是返回True负责返回False | A >= B) 为 False  |
| <=     | 检查左边值是否小于右边，如果是返回True负责返回False | A <= B) 为 False  |

```go
func main() {
   var a int = 11
   var b int = 10
   // 关系运算符返回的都是布尔值

   // 判断 if 如果 ... 结果
   if a > b {
      // 执行一些 a>b 操作
   } else { //else 否则
   
   }
}
```



#### :four_leaf_clover:逻辑运算符

下表列出了所有Go语言的逻辑运算符。加入A值为True，B值为False

> 2件事判断 18岁 和 身份证，满足两个才能进入网吧

| 运算符 | 描述                                                         | 实例             |
| ------ | ------------------------------------------------------------ | ---------------- |
| &&     | 逻辑 and 运算符，如果两边的操作都是True，则条件True，否则为False | (A && B)为False  |
| \|\|   | 逻辑 or 运算符，如果两边的操作有一个True，则条件True，否则为False | (A \|\| B)为True |
| ！     | 逻辑 not 运算符，如果条件为TrueT，则逻辑not条件false，否则为True | !(A && B)为True  |

```go
func main() {
   var a bool = true
   var b bool = false

   // 逻辑 && 与；可以理解为 我和你都要满足
   // a 和 b都为真，true；一个为假结果为假；
   if a == true && b == true {
      fmt.Println(a, b)
   }
   fmt.Println(a && b) //false

   // 逻辑 ||或；一个真结果为真
   if a || b == true {
      fmt.Println(a, b) //true false
   }

   // 逻辑非 ！
   // 可以理解为取反，如果为假，结果为真
   fmt.Println(!a)
}
```



#### :four_leaf_clover:位运算符

> 二进制

Go语言支持的位运算符如下，假设A为60，B为13

60二进制：11 1100

13二进制： 00 1101

| 运算符 | 描述                                                         | 实例                            |
| ------ | ------------------------------------------------------------ | ------------------------------- |
| &      | 按位与运算符“&”是双目运算符，都是1结果位1，否则是0           | (A & B) 结果12，001100          |
| \|     | 按位或运算符“\|”是双目运算符，都是0结果位0，否则是1          | (A \| B) 结果61,111101          |
| ^      | 按位异或运算符“^”是双目运算符，不同位1，相同为0              | (A ^ B)结果49，110001           |
| &^     | 位清空，a&^b,对于b上的每个数值，如果为0，则取a对应位上的数值，如果为1，则取0 | (A &^ B)结果48，110000          |
| <<     | 左移运算符“<<”是双目运算，左移n位就是乘以2的n次方，其功能是吧"<<"左边的运算数的各二进制位全部左移若干位，由“<<”右边的数指定移动到的位数。 | A<<2结果240（60*2^2），11110000 |
| >>     | 右移运算符">>"是双目运算，右移n位就是除以2的n次方，其功能是吧">>"右边的运算数的各二进制位全部右移若干位，由“>>”左边的数指定移动到的位数。 | A>>2结果15（60/4），1111        |

用途：正常情况下很少使用，再底层加解密会使用；将所有的位向左/右移几位，打开后就是乱码了；底层都是二进制；另外一个程序在执行前恢复就完成了解密加密。

底层：高低电频（电路问题）- 二进制汇编

%b：打印二进制

```go
func main() {
   /*
      二进制 0 和 1，逢二进一
      位运算：二进制上的  0：false 1：true
      & : 都是1结果为1，否则是0
      | : 都是0结果为0，否则是1
      60: 0011 1100
      13: 0000 1101
      -------------
      &  0000 1100  同时满足
      |  0011 1101  一个满足
      ^   0011 0001  不同为1，相同为0（异或）
   */
   var a uint = 60
   var b uint = 13
   //位运算
   var c uint
   c = a & b                       //位运算
   fmt.Printf("%d,二进制：%b\n", c, c) //12,二进制：1100;%.8d显示8位

   c = a | b                       //位运算
   fmt.Printf("%d,二进制：%b\n", c, c) //61,二进制：111101

   c = a ^ b                       //位运算
   fmt.Printf("%d,二进制：%b\n", c, c) //49,二进制：110001

   c = a >> 2                      //位运算
   fmt.Printf("%d,二进制：%b\n", c, c) //15,二进制：1111

   c = a << 2                      //位运算
   fmt.Printf("%d,二进制：%b\n", c, c) //240,二进制：11110000
}
```





#### :four_leaf_clover:赋值运算符

下表列出了所有G语言的赋值运算符

| 运算符 | 描述                                             | 实例                 |
| ------ | ------------------------------------------------ | -------------------- |
| =      | 简单的赋值运算符，将一个表达式的值赋值给一个左值 | c = a + b            |
| +=     | 相加后再赋值                                     | c +=a 等于 c =c +a   |
| -=     | 相减后再赋值                                     | c -=a 等于 c =c -a   |
| *=     | 相乘后再赋值                                     | c *=a 等于 c =c *a   |
| /=     | 相除后再赋值                                     | c /=a 等于 c =c /a   |
| %=     | 求余后再赋值                                     | c %=a 等于 c =c %a   |
| <<=    | 左移后赋值                                       | c <<=2 等于 c = c<<2 |
| >>=    | 右移后赋值                                       | c >>=2 等于 c = c>>2 |
| &=     | 按位与后赋值                                     | c&=a 等于 c = c&a    |
| ^=     | 按位异或后赋值                                   | c^=a 等于 c = c^a    |
| \|=    | 按位或后赋值                                     | c\|=a 等于 c = c\|a  |

重点理解上半部分，下半部分不常用

```go
func main() {
   var a int = 21
   var b int

   // =赋值
   b = a
   fmt.Println(b) //21

   // += 加等 b = b + a; 简化代码
   b += a
   fmt.Println(b) //42
}
```



#### :four_leaf_clover:其他运算符

下表列出来Go语言的其他运算符

| 运算符 | 描述               | 实例                     |
| ------ | ------------------ | ------------------------ |
| &      | 返回变量存储的地址 | &a；将给出变量的实际地址 |
| *      | 指针变量           | *a；是一个指针变量       |

















